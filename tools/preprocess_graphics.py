# pyright: reportUnreachable=false

from copy import copy
from math import sqrt
import sys
import re
from enum import IntEnum
from typing import final

if len(sys.argv) < 3:
	print(f"usage: {sys.argv[0]} <input.c> <output.processed.c> [-DDEFINITION=VALUE...]")
	exit()

out_path = sys.argv[2]
assert out_path.endswith(".processed.c"), "ensure the output path is correct"
should_tessellate = "areas/" in out_path

definitions: dict[str, int] = {}

for arg in sys.argv[3:]:
	if arg.startswith("-D"):
		if (eq_idx := arg.find("=")) != -1:
			def_name = arg[2:eq_idx]
			definitions[def_name] = int(arg[eq_idx + 1:])
		else:
			def_name = arg[2:eq_idx]
			definitions[def_name] = 0

definitions["BUGFIX_BOWSER_FADING_OUT"] = 1 if definitions.get("VERSION_US") or definitions.get("VERSION_EU") or definitions.get("VERSION_SH") else 0

@final
class N64Vtx:
	__slots__ = "x", "y", "z", "u", "v", "r", "g", "b", "a"
	x: int
	y: int
	z: int
	u: int
	v: int
	r: int
	g: int
	b: int
	a: int

	def __init__(self, line: str | None = None):
		if line is not None:
			parts = line.replace(" ", "").replace("}", "").replace("{", "").split(",")
			self.x, self.y, self.z, _, self.u, self.v, self.r, self.g, self.b, self.a = \
				tuple(int(parts[i], 0) for i in range(len(parts) - 1))

@final
class N64VtxList:
	__slots__ = "vertices"
	vertices: list[N64Vtx]

	def __init__(self):
		self.vertices = []

	def between(self, a: int, b: int) -> int:
		mid = N64Vtx()
		mid.x = (self.vertices[a].x + self.vertices[b].x) // 2
		mid.y = (self.vertices[a].y + self.vertices[b].y) // 2
		mid.z = (self.vertices[a].z + self.vertices[b].z) // 2
		mid.u = (self.vertices[a].u + self.vertices[b].u) // 2
		mid.v = (self.vertices[a].v + self.vertices[b].v) // 2
		mid.r = (self.vertices[a].r + self.vertices[b].r) // 2
		mid.g = (self.vertices[a].g + self.vertices[b].g) // 2
		mid.b = (self.vertices[a].b + self.vertices[b].b) // 2
		mid.a = (self.vertices[a].a + self.vertices[b].a) // 2
		for i, v in enumerate(self.vertices):
			if v.x == mid.x and v.y == mid.y and v.z == mid.z and v.u == mid.u and v.v == mid.v and v.r == mid.r and v.g == mid.g and v.b == mid.b and v.a == mid.a:
				return i
		idx = len(self.vertices)
		assert idx < 16
		self.vertices.append(mid)
		return idx

static_n64_vtx_lists: dict[str, N64VtxList] = {}
cur_static_n64_vtx_list: N64VtxList = N64VtxList()
n64_vtx_list_lengths: dict[str, int] = {}

out_lines: list[str] = ["// this file is generated by tools/preprocess_graphics.py, see the original file instead\n"]
display_lists: dict[str, "DisplayList"] = {}
display_lists_ordered: list[str] = []

# these cause a lot of glitches for some reason :( might be a bug in the rsp jit though
INLINE = False
INLINE_AGGRESSIVELY = False # inline a call even when there is more than one use

# section: definitions in object form

@final
class Cmd:
	__slots__ = "name", "line", "between_parentheses"
	name: str
	line: str
	between_parentheses: str

	def __init__(self, line: str):
		self.line = line
		rparen_idx = line.rfind(")")
		assert rparen_idx >= len(line) - 2, line
		lparen_idx = line.find("(")
		self.name = line[0:lparen_idx]
		self.between_parentheses = self.line[lparen_idx + 1:rparen_idx]

	def get_args(self) -> list[str]:
		return self.between_parentheses.split(",")

@final
class DisplayList:
	__slots__ = "use_count", "def_line", "name", "cmds"
	use_count: int
	def_line: str
	name: str
	cmds: list[Cmd]

	def __init__(self, def_line: str, name: str):
		self.use_count = 0
		self.def_line = def_line
		self.name = name
		self.cmds = []

	def try_inline(self):
		i = 0
		while i < len(self.cmds):
			cmd = self.cmds[i]
			if cmd.name == "gsSPDisplayList" and (target := display_lists.get(cmd.between_parentheses)):
				if INLINE_AGGRESSIVELY or target.use_count <= 1:
					self.cmds = [*self.cmds[:i], *target.cmds, *self.cmds[i + 1:]]
			i += 1

	def affect_vtx_selection(self, prev: str | None) -> str | None:
		known = prev
		i = 0
		while i < len(self.cmds):
			cmd = self.cmds[i]
			if cmd.name == "gsSPDisplayList":
				target = display_lists.get(cmd.between_parentheses)
				if target is None:
					known = None
				else:
					known = target.affect_vtx_selection(known)
			elif cmd.name == "gsSPVertex":
				known = cmd.get_args()[0]
			i += 1
		return known

	def clean_vtx(self):
		i = 0
		cur_known_vtx: str | None = None
		while i < len(self.cmds):
			cmd = self.cmds[i]
			if cmd.name == "gsSPDisplayList":
				target = display_lists.get(cmd.between_parentheses)
				if target is None:
					cur_known_vtx = None
				else:
					cur_known_vtx = target.affect_vtx_selection(cur_known_vtx)
			elif cmd.name == "gsSPVertex":
				vtx_name = cmd.get_args()[0]
				if vtx_name == cur_known_vtx:
					self.cmds.pop(i)
					i -= 1
				else:
					cur_known_vtx = vtx_name
					# correct the length argument to account for vertices created by tessellation
					if vtx_list := static_n64_vtx_lists.get(vtx_name):
						self.cmds[i] = Cmd(f"gsSPVertex({vtx_name}, {len(vtx_list.vertices)}, 0),")
			i += 1

# section: parsing

class ParseState(IntEnum):
	TopLevel = 0
	CopiedDefinition = 1
	IgnoredDefinition = 2
	MultilineComment = 3
	VertexList = 4
	DisplayList = 5
	DisplayListEnded = 6

#def make_pointer_op(op: str, symbol: str, target_segment: int | None) -> str:
#	segment_in_name = None
#	try:
#		segment_in_name = int(symbol[-8:-6], 16)
#	except:
#		pass
#	if segment_in_name is not None:
#		target_segment = segment_in_name
#	elif target_segment is None:
#		if symbol.startswith("dAmp"):
#			target_segment = 0x08
#		elif symbol.startswith("dl_castle_aquarium_light") or symbol.startswith("dl_castle_lobby_wing_cap_light"):
#			target_segment = 0x07
#		else:
#			raise ValueError(f"could not determine segment of symbol '{symbol}'")
#	return f"(u32) (((void*) {symbol}) + ({op} << 24) - {target_segment << 24}),\n"

cur_display_list: DisplayList | None = None
triangle_queue: list[tuple[str | None, int, int, int] | None] = []
cur_selected_vtx_in_dl: str | None = None

TESSELLATION_THRESHOLD_SQ = 256 * 256

# repeatedly split large triangles in the queue
def tessellate_triangle_queue():
	did_anything = True
	while did_anything:
		did_anything = False
		for tri_idx, tri in enumerate(triangle_queue):
			if tri is not None:
				vtx_list_name, i0, i1, i2 = tri
				if vtx_list_name is not None and (vtx_list := static_n64_vtx_lists.get(vtx_list_name)):
					v0 = vtx_list.vertices[i0]
					v1 = vtx_list.vertices[i1]
					v2 = vtx_list.vertices[i2]
					v0_to_v1_x, v0_to_v1_y, v0_to_v1_z = v1.x - v0.x, v1.y - v0.y, v1.z - v0.z
					v0_to_v1_len_sq = v0_to_v1_x * v0_to_v1_x + v0_to_v1_y * v0_to_v1_y + v0_to_v1_z * v0_to_v1_z
					v1_to_v2_x, v1_to_v2_y, v1_to_v2_z = v2.x - v1.x, v2.y - v1.y, v2.z - v1.z
					v1_to_v2_len_sq = v1_to_v2_x * v1_to_v2_x + v1_to_v2_y * v1_to_v2_y + v1_to_v2_z * v1_to_v2_z
					v0_to_v2_x, v0_to_v2_y, v0_to_v2_z = v2.x - v0.x, v2.y - v0.y, v2.z - v0.z
					v0_to_v2_len_sq = v0_to_v2_x * v0_to_v2_x + v0_to_v2_y * v0_to_v2_y + v0_to_v2_z * v0_to_v2_z
					if v0_to_v1_len_sq >= TESSELLATION_THRESHOLD_SQ and v0_to_v1_len_sq >= v1_to_v2_len_sq and v0_to_v1_len_sq >= v0_to_v2_len_sq:
						if len(vtx_list.vertices) == 16:
							vtx_list = N64VtxList()
							vtx_list.vertices = [copy(v0), copy(v1), copy(v2)]
							i0 = 0
							i1 = 1
							i2 = 2
							vtx_list_name = f"{vtx_list_name}_div{len(static_n64_vtx_lists)}"
							static_n64_vtx_lists[vtx_list_name] = vtx_list
							n64_vtx_list_lengths[vtx_list_name] = 4
						i3 = vtx_list.between(i0, i1)
						triangle_queue[tri_idx] = vtx_list_name, i0, i3, i2
						triangle_queue.append((vtx_list_name, i3, i1, i2))
						did_anything = True
					elif v1_to_v2_len_sq >= TESSELLATION_THRESHOLD_SQ and v1_to_v2_len_sq >= v0_to_v1_len_sq and v1_to_v2_len_sq >= v0_to_v2_len_sq:
						if len(vtx_list.vertices) == 16:
							vtx_list = N64VtxList()
							vtx_list.vertices = [copy(v0), copy(v1), copy(v2)]
							i0 = 0
							i1 = 1
							i2 = 2
							vtx_list_name = f"{vtx_list_name}_div{len(static_n64_vtx_lists)}"
							static_n64_vtx_lists[vtx_list_name] = vtx_list
							n64_vtx_list_lengths[vtx_list_name] = 4
						i3 = vtx_list.between(i1, i2)
						triangle_queue[tri_idx] = vtx_list_name, i0, i1, i3
						triangle_queue.append((vtx_list_name, i0, i3, i2))
						did_anything = True
					elif v0_to_v2_len_sq >= TESSELLATION_THRESHOLD_SQ:
						if len(vtx_list.vertices) == 16:
							vtx_list = N64VtxList()
							vtx_list.vertices = [copy(v0), copy(v1), copy(v2)]
							i0 = 0
							i1 = 1
							i2 = 2
							vtx_list_name = f"{vtx_list_name}_div{len(static_n64_vtx_lists)}"
							static_n64_vtx_lists[vtx_list_name] = vtx_list
							n64_vtx_list_lengths[vtx_list_name] = 4
						i3 = vtx_list.between(i0, i2)
						triangle_queue[tri_idx] = vtx_list_name, i0, i1, i3
						triangle_queue.append((vtx_list_name, i1, i2, i3))
						did_anything = True

# repeatedly split large triangles in the queue
def normalize_triangle_queue_uvs():
	for tri_idx, tri in enumerate(triangle_queue):
		if tri is not None:
			vtx_list_name, i0, i1, i2 = tri
			if vtx_list_name is not None and (vtx_list := static_n64_vtx_lists.get(vtx_list_name)):
				v0 = vtx_list.vertices[i0]
				v1 = vtx_list.vertices[i1]
				v2 = vtx_list.vertices[i2]
				v0u = v0.u * 0xFFFF >> 21
				v1u = v1.u * 0xFFFF >> 21
				v2u = v2.u * 0xFFFF >> 21
				v0v = v0.v * 0xFFFF >> 21
				v1v = v1.v * 0xFFFF >> 21
				v2v = v2.v * 0xFFFF >> 21
				if (v0u >= 64 and v1u >= 64 and v2u >= 64) or (v0v >= 64 and v1v >= 64 and v2v >= 64):
					vtx_list = N64VtxList()
					while v0u >= 64 and v1u >= 64 and v2u >= 64:
						v0u -= 64
						v1u -= 64
						v2u -= 64
					while v0v >= 64 and v1v >= 64 and v2v >= 64:
						v0v -= 64
						v1v -= 64
						v2v -= 64
					v0 = copy(v0)
					v0.u = (v0u << 21) * 0x10000
					v0.v = (v0v << 21) * 0x10000
					v1 = copy(v1)
					v1.u = (v1u << 21) * 0x10000
					v1.v = (v1v << 21) * 0x10000
					v2 = copy(v2)
					v2.u = (v2u << 21) * 0x10000
					v2.v = (v2v << 21) * 0x10000
					vtx_list.vertices = [v0, v1, v2]
					vtx_list_name = f"{vtx_list_name}_norm{len(static_n64_vtx_lists)}"
					static_n64_vtx_lists[vtx_list_name] = vtx_list
					n64_vtx_list_lengths[vtx_list_name] = 3
					triangle_queue[tri_idx] = vtx_list_name, 0, 1, 2

# consider one triangle to write, potentially merging it with a second one into a quadrangle
def flush_single_triangle(t0_idx: int):
	assert cur_display_list is not None
	t0 = triangle_queue[t0_idx]
	if t0 is not None:
		for t1_idx, t1 in enumerate(triangle_queue):
			if t0_idx != t1_idx and t1 is not None:
				t0vtx, t0i0, t0i1, t0i2 = t0
				t1vtx, t1i0, t1i1, t1i2 = t1
				if t0vtx is None or t0vtx != t1vtx:
					continue
				for _t0_rotation in range(3):
					for _t1_rotation in range(3):
						if t1i0 == t0i2 and t1i1 == t0i1:
							triangle_queue[t0_idx] = None
							triangle_queue[t1_idx] = None
							if t0vtx:
								cur_display_list.cmds.append(Cmd(f"gsSPVertex({t0vtx}, {n64_vtx_list_lengths[t0vtx]}, 0),"))
							cur_display_list.cmds.append(Cmd(f"gsSPPortQuadrangle({t0i0}, {t0i1}, {t0i2}, {t1i2}),"))
							return
						t1i0, t1i1, t1i2 = t1i2, t1i0, t1i1
					t0i0, t0i1, t0i2 = t0i2, t0i0, t0i1

def flush_triangle_queue():
	if len(triangle_queue) == 0:
		return
	#if should_tessellate:
	#	tessellate_triangle_queue()
	#normalize_triangle_queue_uvs()
	assert cur_display_list is not None
	for t0_idx in range(len(triangle_queue)):
		flush_single_triangle(t0_idx)
	last = None
	for t in triangle_queue:
		if t is not None:
			if last is None:
				last = t
			else:
				if last[0] == t[0]:
					if t[0]:
						cur_display_list.cmds.append(Cmd(f"gsSPVertex({t[0]}, {n64_vtx_list_lengths[t[0]]}, 0),"))
					cur_display_list.cmds.append(Cmd(f"gsSP2Triangles({last[1]}, {last[2]}, {last[3]}, 0, {t[1]}, {t[2]}, {t[3]}, 0),"))
				else:
					if last[0]:
						cur_display_list.cmds.append(Cmd(f"gsSPVertex({last[0]}, {n64_vtx_list_lengths[last[0]]}, 0),"))
					cur_display_list.cmds.append(Cmd(f"gsSP1Triangle({last[1]}, {last[2]}, {last[3]}, 0),"))
					if t[0]:
						cur_display_list.cmds.append(Cmd(f"gsSPVertex({t[0]}, {n64_vtx_list_lengths[t[0]]}, 0),"))
					cur_display_list.cmds.append(Cmd(f"gsSP1Triangle({t[1]}, {t[2]}, {t[3]}, 0),"))
				last = None
	if last is not None:
		if last[0]:
			cur_display_list.cmds.append(Cmd(f"gsSPVertex({last[0]}, {n64_vtx_list_lengths[last[0]]}, 0),"))
		cur_display_list.cmds.append(Cmd(f"gsSP1Triangle({last[1]}, {last[2]}, {last[3]}, 0),"))
	triangle_queue.clear()

model_c_path = sys.argv[1]
with open(model_c_path, "r") as in_file:
	in_lines = in_file.readlines()

# quickly preprocess conditional directives by marking what lines should be excluded
line_should_be_excluded: list[bool] = []
exclusion_depth = 0
for line_idx, line in enumerate(in_lines):
	if (comment_idx := line.find("//")) != -1:
		line = line[:comment_idx]
	line = line.strip()
	should_exclude_line = exclusion_depth > 0
	if exclusion_depth > 0:
		if line.startswith("#else") and exclusion_depth == 1:
			exclusion_depth -= 1
		elif line.startswith("#elif") and exclusion_depth == 1:
			condition = line[6:].strip()
			if condition.isidentifier():
				if definitions[condition] != 0:
					exclusion_depth -= 1
			elif matches := re.match(r"defined\(([A-Za-z_0-9]+)\)(?: \|\| defined\(([A-Za-z_0-9]+)\))*", condition):
				for match in matches.groups():
					if match in definitions:
						exclusion_depth -= 1
						break
			else:
				raise RuntimeError(f"unhandled condition in {model_c_path}:{line_idx + 1}")
		elif line.startswith("#ifdef") or line.startswith("#ifndef") or line.startswith("#if"):
			exclusion_depth += 1
		elif line.startswith("#endif"):
			exclusion_depth -= 1
	elif line.startswith("#ifdef"):
		should_exclude_line = True
		name = line[7:].strip()
		assert name.isidentifier(), f"non identifier condition in {model_c_path}:{line_idx + 1}"
		if name not in definitions:
			exclusion_depth += 1
	elif line.startswith("#ifndef"):
		should_exclude_line = True
		name = line[8:].strip()
		assert name.isidentifier(), f"non identifier condition in {model_c_path}:{line_idx + 1}"
		if name in definitions:
			exclusion_depth += 1
	elif line.startswith("#if"):
		should_exclude_line = True
		condition = line[4:].strip()
		if condition.isidentifier():
			if definitions[condition] == 0:
				exclusion_depth += 1
		elif matches := re.match(r"defined\(([A-Za-z_0-9]+)\)(?: \|\| defined\(([A-Za-z_0-9]+)\))*", condition): # chain of defined(X)s ored together
			found_any = False
			for match in matches.groups():
				if match in definitions:
					found_any = True
					break
			if not found_any:
				exclusion_depth += 1
		else:
			raise RuntimeError(f"unhandled condition in {model_c_path}:{line_idx + 1}")
	elif line.startswith("#else") or line.startswith("#elif"):
		should_exclude_line = True
		exclusion_depth += 1
	elif line.startswith("#endif"):
		should_exclude_line = True
	line_should_be_excluded.append(should_exclude_line)
#assert len(exclusion_stack) == 0, f"unmatched conditional directive somewhere in {model_c_path}"

state = ParseState.TopLevel
cur_file_segment: int | None = None
cur_flags = "0"
for line_idx, line in enumerate(in_lines):
	if line_should_be_excluded[line_idx]:
		continue
	line: str = line.strip()
	if line.startswith("// 0x"):
		prev = cur_file_segment
		cur_file_segment = int(line[5:7], 16)
		assert prev is None or cur_file_segment == prev
		continue
	if len(line) == 0 or line.startswith("//"):
		continue
	if line.startswith("#") and state != ParseState.MultilineComment:
		out_lines.append(line + "\n")
		continue
	match state:
		case ParseState.TopLevel:
			elems = line.split(" ")
			if line.startswith("/*"):
				state = ParseState.MultilineComment
			elif elems[0] == "UNUSED":
				if not line.endswith(";"):
					state = ParseState.IgnoredDefinition
			else:
				is_static = False
				for i, e in enumerate(elems):
					match e:
						case "ALIGNED8" | "const":
							pass
						case "static":
							is_static = True
						case "Lights1" | "Movtex" | "f32" | "q32" | "Collision" | "Mtx" | "LevelScript" | "GeoLayout" | "struct": # simply copy a definition over
							out_lines.append(line + "\n")
							state = ParseState.CopiedDefinition
							break
						case "Texture" | "u8": # no need for 8 bytes of alignment on psx
							out_lines.append(line.replace("ALIGNED8", "ALIGNED4") + "\n")
							state = ParseState.CopiedDefinition
							break
						case "Vtx": # TODO
							name = elems[i + 1]
							assert name.endswith("[]")
							if is_static:
								#out_lines.append(f"static const Vtx {name} = {{\n")
								state = ParseState.VertexList
								static_n64_vtx_lists[name[:-2]] = cur_static_n64_vtx_list
								break
							else:
								#out_lines.append(f"const Vtx {name} = {{\n")
								out_lines.append(line + "\n")
								state = ParseState.CopiedDefinition
								break
						case "Gfx":
							name = elems[i + 1]
							assert name.endswith("[]")
							name = name[:-2]
							cur_display_list = DisplayList(line, name)
							state = ParseState.DisplayList
							cur_flags = "0"
							cur_selected_vtx_in_dl = None
							break
						case "s16":
							if is_static: # the only time this is used, it is unused
								state = ParseState.IgnoredDefinition
							else:
								out_lines.append(line + "\n")
								state = ParseState.CopiedDefinition
							break
						case _:
							raise ValueError(f"unhandled identifier {e} in {model_c_path}:{line_idx + 1}")
		case ParseState.CopiedDefinition:
			if line.startswith("};") or line.startswith(");"):
				state = ParseState.TopLevel
			out_lines.append(line + "\n")
		case ParseState.IgnoredDefinition:
			if line.startswith("};") or line.startswith(");"):
				state = ParseState.TopLevel
		case ParseState.MultilineComment:
			if line.endswith("*/"):
				state = ParseState.TopLevel
		case ParseState.VertexList:
			if line.startswith("};"):
				state = ParseState.TopLevel
				cur_static_n64_vtx_list = N64VtxList()
			else:
				assert line.startswith("{{{") and line.endswith("}}},")
				cur_static_n64_vtx_list.vertices.append(N64Vtx(line))
				#rgb = r | g << 8 | b << 16
				#out_lines.append(line + "\n")
				#out_lines.append(f"{{.tag=COMPILED_TAG,.psx={{.x={x},.y={y},.z={z},.u={min(max((u*0xffff>>21) + 64, 0), 255)},.v={min(max((v*0xffff>>21) + 64, 0), 255)},.color.as_u32={rgb}}}}},\n")
		case ParseState.DisplayList:
			if line.startswith("};"):
				raise ValueError(f"display list ended prematurely in {model_c_path}:{line_idx + 1}")
			else:
				if (comment_idx := line.find("//")) != -1:
					line = line[0:comment_idx].strip()
				cmd = Cmd(line)
				match cmd.name:
					case "gsSPEndDisplayList" | "gsSPBranchList":
						flush_triangle_queue()
						cur_display_list.cmds.append(cmd)
						state = ParseState.DisplayListEnded
					case "gsSP1Triangle":
						args = cmd.get_args()
						triangle_queue.append((cur_selected_vtx_in_dl, int(args[0].strip()), int(args[1].strip()), int(args[2].strip())))
					case "gsSP2Triangles":
						args = cmd.get_args()
						triangle_queue.append((cur_selected_vtx_in_dl, int(args[0].strip()), int(args[1].strip()), int(args[2].strip())))
						triangle_queue.append((cur_selected_vtx_in_dl, int(args[4].strip()), int(args[5].strip()), int(args[6].strip())))
					case "gsDPSetTile":
						if "G_TX_RENDERTILE" in line:
							cur_display_list.cmds.append(cmd)
					case "gsSPDisplayList":
						if target := display_lists.get(cmd.between_parentheses):
							target.use_count += 1
							cur_selected_vtx_in_dl = target.affect_vtx_selection(cur_selected_vtx_in_dl)
						else:
							cur_selected_vtx_in_dl = None
						flush_triangle_queue()
						cur_display_list.cmds.append(cmd)
					case "gsSPVertex":
						args = cmd.get_args()
						cur_selected_vtx_in_dl = args[0].strip()
						n64_vtx_list_lengths[cur_selected_vtx_in_dl] = int(args[1].strip())
						#if n64_vtx_list := static_n64_vtx_lists.get(args[0].strip()):
						#	if cur_selected_vtx_in_dl:
						#
						#else:
							#	flush_triangle_queue()
							#	#cur_display_list.cmds.append(cmd)
					case "gsSPSetGeometryMode" | "gsSPClearGeometryMode" | "gsDPSetCombineMode" | "gsDPSetTextureImage" | "gsDPLoadTextureTile" | "gsDPLoadTextureBlock" | "gsSPTextureRectangle" | "gsSPTexture" | "gsSPLight" | "gsSPNumLights" | "gsSPSetLights1" | "gsSPSetEnvColor":
						flush_triangle_queue()
						cur_display_list.cmds.append(cmd)
					case _:
						pass
		case ParseState.DisplayListEnded:
			if line.startswith("};"):
				display_lists_ordered.append(cur_display_list.name)
				assert cur_display_list is not None
				display_lists[cur_display_list.name] = cur_display_list
				cur_display_list = None
				state = ParseState.TopLevel
			else:
				raise ValueError(f"display list did not end when expected in {model_c_path}:{line_idx + 1}")

# section: optimize

for name in display_lists_ordered:
	dl = display_lists[name]
	if INLINE:
		dl.try_inline()
	dl.clean_vtx()

# section: output

for name in static_n64_vtx_lists:
	vtx_list = static_n64_vtx_lists[name]
	out_lines.append(f"static const Vtx {name}[] = {{\n")
	for vtx in vtx_list.vertices:
		out_lines.append(f"{{{{{{{vtx.x}, {vtx.y}, {vtx.z}}}, 0, {{{vtx.u}, {vtx.v}}}, {{{vtx.r}, {vtx.g}, {vtx.b}, {vtx.a}}}}}}},\n")
	out_lines.append("};\n")

for name in display_lists_ordered:
	dl = display_lists[name]
	if INLINE:
		dl.try_inline()
	out_lines.append(dl.def_line + "\n")
	for cmd in dl.cmds:
		out_lines.append(cmd.line + "\n")
	out_lines.append("};\n")

with open(out_path, "w") as out_file:
	out_lines.insert(0, "#include <port/gfx/gfx_internal.h>") # needed for GfxVtx
	out_file.writelines(out_lines)
